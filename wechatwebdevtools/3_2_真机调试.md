# 真机调试
## 触发真机调试
```
async remoteDebug(a) {
    if (a.stopPropagation(),
    !(this.props.actionBtnDisabled || this.props.toolbarConfigShow)) {
        const b = H.get(y.WINDOW_REGISTRY.REMOTE_DEBUG_WINDOW);
        if (b)
            return void b.focus();
        if (this.props.remoteDebugWindow.debuggingProjectId)
            return this.props.project.projectid === this.props.remoteDebugWindow.debuggingProjectId ? void 0 : void this.showErr(z.config.TOOLBAR_REMOTE_DEBUG_ERROR);
        this.props.windowActions.setRemoteDebugWindow({
            debuggingProjectId: this.props.project.projectid
        });
        const c = a.currentTarget.getBoundingClientRect();
        this.props.toolbarActions.toggleRemoteDebugCode({
            left: c.left,
            top: c.top
        }), 
        this.setState({
            timeStamp: 1 * new Date
        })
    }
}
```
1. this.props.toolbarActions.toggleRemoteDebugCode  触发显示真机调试二维码
  - js/fc137838572a83604db39acff8e909e0.js
    ```
    toggleRemoteDebugCode: function(a) {
      return {
          type: l.TOOLBAR_REMOTE_DEBUG_CODE,
          data: a
      }
    },

    ```
    - js/f81bd6d4e666827b025a83f7fc13cbce.js
    ```
    case d.TOOLBAR_REMOTE_DEBUG_CODE:
      return _extends({}, c, {
          clickKey: e.REMOTEDEBUGCODE
      });
    ```
    - js/629ccf62fc18c4d6caab59c1e6619a09.js
    详细见 扫描二维码预览或真机调试 章节

2. this.props.windowActions.setRemoteDebugWindow
    - js/a8c87029da0fa06e986298d447ab0fe2.js
    ```
    setRemoteDebugWindow: (a)=>async(b,c)=>{
        if (a.show) {
            const a = c();
            if (a.window.remoteDebugWindow.show)
                try {
                    const a = await g.onWindowRegistered(e.WINDOW_REGISTRY.REMOTE_DEBUG_WINDOW);
                    return void a.window.focus()
                } catch (a) {}
         }
        b({
            type: d.WINDOW_SET_REMOTE_DEBUG_WINDOW,
            data: a
        })
    }
    ```
    - js/cec6fa445b36e82b831c3020815b08b9.js
    ```
    case e.WINDOW_SET_REMOTE_DEBUG_WINDOW:
        return _extends({}, h, {
            remoteDebugWindow: _extends({}, h.remoteDebugWindow, i.data)
        }); 
    ```

## 扫描二维码预览或真机调试
629ccf62fc18c4d6caab59c1e6619a09.js
1. 自定义预览前预处理
2. 获取有效端口
3. 上传代码 d(j) js/f0466135fc8b3a662084784e5f4ac792.js 详细见 上传代码 章节
    ```
    module.exports = async function(a) {
        return B.enqueueBuildTask(b.bind(null, a), B.buildType.upload)
    }
    ```
    上传代码成功后，获取了很多信息，例如：wxpkg_info、room_id、qrcode_img、username等。 其中qrcode_img用来渲染生成二维码
    
4. 初始化调试环境 l.init js/63f52c9055d92f52ca0510da7d3dcadb.js 详细见 初始化调试环境 章节
    ```
    let j = await l.init(g.project,{wxpkg_info:c,room_id:d,username:h,appid:g.project.appid},  
    { 
      usingLocalStorage:g.remoteDebugWindow.usingLocalStorage,
      remoteDebugLocal:global.l,
      clientProxyPort:i,
      onStatusUpdate:(b,c)=>{
           this.state.show && (c && j && j.url ?(this.props.windowActions.setRemoteDebugWindow({show:!0,inspectUrl:j.url,serverInfo:a}),
           this.setState({show:!1}),
           this.props.toggleClickKey(f.NONE)):this.setState({remoteDebugStatus:b}))},
      onProgressUpdate:b,
      onEvent:(a)=>{this.state.show&&this.setState({remoteDebugEvents:(this.state.remoteDebugEvents||[]).concat(a)})},
      isGame:'game'===g.project.compileType})
    ```
  - onStatusUpdate 更新状态信息设置远程调试窗口，或this.setState.remoteDebugStatus
    ```
      REMOTE_DEBUG_END: '已结束，请重新开始',
      REMOTE_DEBUG_NOT_UNINITIALIZED: '未初始化',
      REMOTE_DEBUG_NOT_CONNECTED: '未连接',
      REMOTE_DEBUG_LOGOUT: '已登出',
      REMOTE_DEBUG_LOGINING: '正在登陆',
      REMOTE_DEBUG_WAIT_SERVICE: '等待设备',
      REMOTE_DEBUG_SERVER_BLOCKING: '服务器阻塞',
      REMOTE_DEBUG_WAITING_FOR_RESPONSE: '等待回包',
      REMOTE_DEBUG_WORK_CORRECTLY: '正常',
      REMOTE_DEBUG_UNKNOWN: '未知',
    ```
  - onProgressUpdate  更新进度信息设置 this.state.progressDetailedText 和 this.state.stage
  - onEvent 设置 this.state.remoteDebugEvents
5. 获取remoteDebugWindow窗口需加载的url（node inspector）
    - DebugServer，启动websocket Server （cp）
    - remote-helper，建立websocket Client （cp），使用nodejs的inpsector.url()获取url
    - DebugServer监听客户端的vmReady消息，获取url，然后发送initSuccess消息
    - RemoteDebug 监听initSuccess，获取真机调试窗口的url
6. RemoteDebug中的Messager负责监听远程服务端(RemoteUrl= wss://wxagame.weixin.qq.com/remote/)的消息，根据响应回调onStatusUpdate从而更新this.state.remoteDebugStatus。如果正常的话，则二维码窗口消失，真机调试窗口出现。

### 上传代码
f0466135fc8b3a662084784e5f4ac792.js
1. 获取项目相关信息
2. 编译代码  js/911222a6723da8db7ca8a8e3689591e1.js
    ```
    const u = await l(i,{noCompile:!0,onProgressUpdate:q,onFilesIgnored:b.onFilesIgnored});
    ```
3. 打包 js/e5fa35c3c8e81bc6466b4b8eb436113b.js
    文件存放在(~/Library/Application Support/微信web开发者工具/Weappdest/${+new Date}.wx) 
4. 上传 
    - 此处会控制文件大小
    - 上传请求路径：https://servicewechat.com/wxa-dev/commitsource?user-version=${c}&user-desc=${a}&uuid=${d}&gzip=1
    ```
    {
        url: `${S}&devplugin=${i.compileType == x.plugin ? 1 : 0}`,
        method: 'post',
        body: U,  //打包后的文件
        needToken: 1,
        needAppID: 1
    }      
    ```
    - 得到请求响应，获得wxpkg_info、room_id、qrcode_img、username等信息
    
### 初始化调试环境
63f52c9055d92f52ca0510da7d3dcadb.js
1. 初始化调试环境
    - RemoteDir = ~/Library/Application Support/微信web开发者工具/WeappRemote/
    - RemoteTempDir = ~/Library/Application Support/微信web开发者工具/WeappRemote/temp/
    - RemoteDataDir = ~/Library/Application Support/微信web开发者工具/WeappRemote/data/
    - 有RemoteDir、RemoteTempDir 等目录则清除，然后重新创建RemoteDir、RemoteTempDir、RemoteDataDir 目录。
2. 准备文件
    - 读取项目目录下的app.json文件
    - 缓存以项目根路径作为参数的FileUtils对象，并监听all事件(即watch所有的文件)
    - 遍历除app.json外的所有json文件，获取ext.json相关的扩展component。（?)
    - 准备所有的components、Page、js文件、wxappcode.js、wxmlxcjs.js、w.getServiceCode、wxplugincode.js、wacloud.js
3. 初始化调试实例RemoteDebug js/6c6f4dde020ed24929c4c4367c42d34d.js
    ```
    B = new n({  // n=RemoteDebug
        files: j,  //所有处理好的文件
        dir: u,    // RemoteDir
        tempDir: v, // RemoteTempDir
        dataDir: w,  // RemoteDataDir
        initialRoomInfo: _extends({}, g),
        config: _extends({}, m),
        mode: m.remoteDebugLocal ? m.remoteDebugLocal : 'server',
        clientProxyPort: m.clientProxyPort,
        cdpEnabled: !!m.isGame
    });
    
    s('remotedebug', z.config.INITIALIZE_DEBUG_INSTANCE),  // 初始化调试实例
    await B.init(),
    s('remotedebug', z.config.WAITING_FOR_PROCESS)  // 等待进程
    ```
    - 监听initsuccess：获得了remoteDebug窗口地址为：`chrome-devtools://devtools/bundled/inspector.html?experiments=true&ws=${inspectUrl.replace(/^ws\:\/\//i, "")}`
    - 监听statuschange：根据响应回调 onStatusUpdate
    
### 调试实例RemoteDebug
6c6f4dde020ed24929c4c4367c42d34d.js
1. 初始化init
    - 模式mode：server模式、remoteDebugLocal(andorid、ios)模式。如果是android的本地模式，则也是使用adbkit，获取设备信息并获取用户的授权。
    - 新建DebugServer js/ce02bd5f4368747c4e2fff84ed0fc0de.js
        ```
        this.debugServer = new h.DebugServer({
                port: d,
                mode: this.mode,
                androidDeviceId: a,
                clientProxyPort: this.clientProxyPort
        }),
        ```
     - 新建Messager js/02a96d04e49a39ea9d70e3d9d372379a.js
        ```
        this.messager = "server" === this.mode ? new b.Messager({
            tempDir: this.tempDir,
            initialRoomInfo: this.initialRoomInfo
        }) : new c.LocalMessager({
            roomInfo: this.initialRoomInfo,
            debugServerPort: d,
            debugServer: this.debugServer
        }),
        ```
      - DebugServer 及 Messager 的初始化、事件监听
        ```
        this.debugServer.on("cpmessage", this.onCpWsMessage.bind(this)),
        this.messager.on("statuschange", this.onMessagerStatusChange.bind(this)),
        this.messager.on("debugmessage", this.onDebugMessage.bind(this)),
        this.messager.onAskForRetry(this._askForRetryFn),
        this.messager.on("accident", this.onMessagerAccident.bind(this)),
        this.messager.on("event", this.onMessagerEvent.bind(this)),
        this.messager.on("datasendreport", this.onMessagerDataSendReport.bind(this));
        try {
            await this.messager.init(),
            await this.debugServer.init()
        } catch (a) {
            throw z.e(a),
            a
        }
        ```
      - 创建子进程执行remote-helper.js，其中参数有：
        ```
        const g = {
                wsurl: `ws://127.0.0.1:${d}`,
                httpPort: (global.proxyPort || 9973) + "",
                initialInspectPort: (await E(!0)) + "",
                dir: this.dir,
                tempDir: this.tempDir,
                dataDir: this.dataDir,
                usingLocalStorage: this.usingLocalStorage ? "yes" : "no",
                isDev: f.isDev ? "yes" : "no",
                files: JSON.stringify(this.files),
                vendorDir: y
            }
              , j = this.cp = o.fork(x, [], {  // x = remote-helper.js  o=require("node-sync-ipc").parent()
                execPath: w,   //w = node的路径
                env: g
            });
        ```
      - 子进程remote-helper.js监听的事件
        ```
            j.on("message", this.onCpMessage.bind(this)),
            j.onSync("sdksyncapi", this.onCpSyncMessage.bind(this)),
            j.onSync("sdkstorageapi", this.onCpStorageMessage.bind(this)),
            this.messager.on("destroy", this.onMessagerDestroy.bind(this)),
            j.on("disconnect", e),
            j.on("close", e),
            j.on("exit", (a)=>{
                z.w("cp exited with code " + a),
                e("child process exit " + a)
            }
            ),
            j.on("error", (a)=>{
                z.e("cp encountered error", a && a.toString()),
                e(a && a.toString())
            }
        ```
2. DebugServer, websocketServer。
    - 创建ws server
        ```
        const a = this.wss = new f.Server({  // f = require('ws')
                perMessageDeflate: !1,
                port: this.port
            });
        ```
    - 监听connection，赋值this.client。处理client端的消息onClientWsMessage，区分是否cp，如果是cp，则赋值this.cpws消息处理为onCpWsMessage。
    - onCpMessage，本身作为EventEmitter，this.emit("cpmessage", a)。 即将cp客户端发送的消息转发给监听事件cpmessage的函数处理。
    - this.debugServer.on("cpmessage", this.onCpWsMessage.bind(this)), 处理的第一个类型为type=‘vmReady’
        ```
        setTimeout(()=>this.emit("initsuccess", {
            url: `chrome-devtools://devtools/bundled/inspector.html?experiments=true&ws=${inspectUrl.replace(/^ws\:\/\//i, "")}`
         }), 0),
         // q = p.get("storage_remotedebug")  // WebSocketServer,其中命名空间为PLUGIN_storage_remotedebug
         q.register(this._onRemoteDebugMessage = this.onRemoteDebugMessage.bind(this)),
         // r = p.get("wxml_remotedebug")  //WebSocketServer,其中命名空间为PLUGIN_wxml_remotedebug
         r.register(this._onWxmlRemoteDebugMessage = this.onWxmlRemoteDebugMessage.bind(this)),
         // s = p.get("appdata_remotedebug")  //WebSocketServer,其中命名空间为PLUGIN_appdata_remotedebug
         s.register(this._onAppDataRemoteDebugMessage = this.onAppDataRemoteDebugMessage.bind(this)),
         // WebSocketServer,命名空间为REMOTEDEBUGDEVTOOLS
         t.register(this._onRemoteDebugDevtoolsMessage = this.onRemoteDebugDevtoolsMessage.bind(this)),
        ```
    - 如果是ios插线调试：则使用ios-remote-debug-proxy/WARemoteDebugProxy
        ```
        l = j.join(process.execPath, "../../../../../Resources/bin/ios-remote-debug-proxy/WARemoteDebugProxy")
        const a = this.cp = h.spawn(l, [`--wsurl=ws://localhost:${this.port}`, `--usbport=${this.clientProxyPort}`]);
        ```
    - 如果是android插线调试：则使用adb-kit
        ```
        async initAdb() {
            const a = await n.version();  // n为adb-kit的封装
            s.i("adb version running", a);
            const b = this.androidDeviceId
            , c = this.clientProxyPort
            , d = this.port;
            await n.reverse(b,`tcp:${c}`,`tcp:${d}`)  // 把PC上的clientProxyPort 映射到 安卓手机上的this.port
        }
        ```
3. Messager， websocket Client
    - 创建ws 客户端
        ```
        const a = this.ws = new f(h.RemoteUrl); // f= require("ws"); h.RemoteUrl= wss://wxagame.weixin.qq.com/remote/
        ```
    - 监听服务端的消息，解码报文并处理相对应的消息
        通过protobufjs解码获得{data，cmd，uuid}，其中cmd有:Heartbeat、Login、EventNotifyEnd、EventNotifyBlock、EventNotifyBegin、JoinRoom、MessageNotifyParallelly、MessageNotify、QuitRoom、SendDebugMessageParallelly、SendDebugMessage、SyncMessage。 
        
        在收到的MessageNotify中类型为DebugMessageCategory中的Breakpoint、CallInterface、CallInterfaceResult、EvaluateJavascript、EvaluateJavascriptResult、Ping、Pong、SetupContext、DomOp、DomEvent、NetworkDebugAPI、ChromeDevtools、ChromeDevtoolsResult、AddJsContext、RemoveJsContext、ConnectJsContext
        
    - setStatusByResponse：根据响应获取状态。并发送statuschange事件,一路传递到RemoteDebug实例中，
        ```
        this.emit("statuschange", a, b)  // Messager
        this.messager.on("statuschange", this.onMessagerStatusChange.bind(this)), // RemoteDebug中实例化Message
        B.on('statuschange', () => {   // B是RemoteDebug的实例，k为onStatusUpdate
            A || (A = setTimeout(() => {
                    A = void 0;
                    for (const a of C)
                        a();
                    const a = B && B.messager && B.messager.status;
                    k(a, 4 < a)
            }, 400))
        })
        ```
    - 
        
4. 子进程remote-helper.js, websocket clinet
    - inspector.open(initialInspectPort) : 激活inspector
    - initWs，初始化Websocket客户端，连接上websocket Server后，notifyMaster
        ```
        function notifyMaster() {
            sendMessageToMaster({
                type: 'vmReady',
                data: {
                    inspectUrl: inspector.url(),
                },
            });
        }
        ```
     - 监听服务端的消息：handleSetupContext、handleEvaluateJavascript、handleCallInterfaceResult、debugEnable、getWXAppDatas、setWXAppDatas、exchange等。
     - 根据Chrome DevTools的原理，那么node inspector会作为Chrome DevTools工具的ws的服务端

## 远程调试窗口（React.Component)
5fce949eb42d709c19a90da9440a955b.js
1. render
    ```
    render() {
            return b.createElement(e, { 
                title: h.config.TOOLBAR_REMOTE_DEBUG,
                width: 1024,
                height: 800,
                min_width: 600,
                min_height: 600,
                resizable: !0,
                registryId: 'REMOTE_DEBUG_WINDOW',
                onWindowClose: this.props.closeRemoteDebugWindow,
                templateHTML: 'html/popup-debugger.html',
                renderClass: j
            })
    }
    ```
2. 组件j，远程调试窗口的渲染 js/c9088b8c1e58e44a737f97a08c5a116e.js
    - 订阅状态变化subscribeChange
    - 订阅事件subscribeEvent
    - 监听相关事件：onAskForRetry、onOpenEditorFile
    - onStatusChange
    - 创建左侧调试窗口webview，设置UserAgent和url
        ```
        j.showDevTools(!0, c);
        const a = this.props.project.compileType
        , b = i.getSessionToken(e.UA_TOKEN)
        , d = this._oldUa || c.getUserAgent()
        , f = `${d} remotedebugdevtools ${this.props.remote.usingLocalStorage ? 'usinglocalstorage' : ''} port/${global.messageCenterPort} proxy/${global.proxyPort} token/${b} compileType/${a}`;
        c.setUserAgentOverride(f),
        c.src = `${this.props.remote.inspectUrl}`,
        ```
     - 监听dialog事件，处理messageText的类型：debugger:paused、debugger:resumed、opennewtab:、opennewtab: 

# 涉及到的第三方库及需要进一步了解的内容
1. node-sync-ipc
2. Reflect.decorate（typescript）
3. nodejs的vm模块、inspector模块
