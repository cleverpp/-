# 扫码登录(React.Component)
![登录界面](https://github.com/cleverpp/SourceAnalytics/blob/master/wechatwebdevtools/assets/LOGIN.png)
## 二维码的状态
```
        LOGIN_QR_STATUS: {
            NOT_SCAN: 1,    //未扫码
            SCAN: 2,        //扫码
            CONFIRM: 3,     //确认
            CANCEL: 4,      //取消
            OUTDATED: 5,    //超时
            NETWORK_ERROR: 6,   //网络错误
            OCCUPIED: 7,      // 被占用？
            REDIRECT_NETWORK_ERROR: 8,  //重定向网络错误
            UNKNOWN: 10   // 未知
        },
```
## 还原render
```
<div class="container" style={{WebkitAppRegion:"drag"}}>
    <div>
        <div>
            <c />    //组件c 是标题栏，区分window与mac平台，其中windows支持打开proxy：this.props.openIDESettings('proxy')
            <div class="welcome">
                <div class="welcome-hd">
                    <h2>微信开发者工具</h2>
                    <p>vglobal.appVersion</p>
                </div>
                <div class="welcome-hd">
                    <div class="authenticate">
                        <div class="authenticate-bd"> 
                            //组件d 核心逻辑：生成二维码，并根据用户是否扫码进行响应
                            <d ref={(a)=>this.qr=a} from="mainlogin" setStatus={this._setStatus} onLoginSuccess={this.props.loginSuccess} />
                        </div>
                        <div class="authenticate-ft">
                            <p>欢迎使用微信开发者工具</p>
                        </div>
                    </div>
                </div>
                <div class="welcome-ft" style={{e}}>
                    <div class="luncher-account">
                        <div class="luncher-account-avatar"></div>
                        <div class="luncher-account-name" onClick={this.reset.bind(this)}>
                            <p>切换账号</p>
                            <i class="ui-icon-arrow-right-o"/>
                        </div>    
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
```
## 组件d：扫码登录
- 还原render

        ```
        <div className="authenticate-qrcode">
            <img ref={ref=(a)=>this.QRCodeImgElement=a}/>
            <i className="ui-icon-mini-app-circle"/>
            <div className="authenticate-result">
                <i className="ui-icon-tick-circle"/>
                <h4 className="authenticate-result-title">扫描成功</h4>
            </div>
            <div className="authenticate-result">
                <a><i className="ui-icon-reload" onClick={this.reset.bind(this)}/></a>
                <h4 className="authenticate-result-title authenticate-result-title-warn">二维码过期</h4>
                <p className="authenticate-result-subtitle">请手动刷新</p>
            </div>
            <div className="authenticate-result">
                <a><i className="ui-icon-reload" onClick={this.reset.bind(this)}/></a>
                <h4 className="authenticate-result-title authenticate-result-title-warn">网络错误，状态码：%s</h4>
                <p className="authenticate-result-subtitle">请检查网络设置，然后手动刷新</p>
            </div>
            <div className="authenticate-result">
                <a><i className="ui-icon-reload" onClick={this.reset.bind(this)}/></a>
                <h4 className="authenticate-result-title authenticate-result-title-warn">未知错误</h4>
                {this.state.errMsg?
                    <p className="authenticate-result-subtitle">{this.state.errMsg}</p>
                    :<p className="authenticate-result-subtitle">请检查网络设置，然后手动刷新</p>}
            </div>
            <div className="authenticate-result">
                <a><i className="ui-icon-reload" onClick={this.reset.bind(this, LOGIN_QR_STATUS.OCCUPIED)}/></a>
                <h4 className="authenticate-result-title authenticate-result-title-warn"></h4>
                <p className="authenticate-result-subtitle">登录二维码正被终端或 HTTP 服务占用，如需终止，点此刷新</p>
            </div>
        </div>
        ```
- 核心逻辑
  1. this.reloadQRCode()
     1. 发请求：request({url:'https://servicewechat.com/connect/qrconnect?appid=wxde40e023744664cb&redirect_uri=https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/qrcode&scope=snsapi_login&state=login#wechat_redirect'}) 获取url
     2. 根据第一步的url获取 二维码图像qrcode，长轮询longPollURL=
        ```
        /"(https:\/\/long.open.weixin.qq.com\/connect\/l\/qrconnect\?uuid=.+?)"/
        ```
     3. 长轮询获取javascript,eval(javascript)获取用户是否扫码以及扫码结果
        - 用户在微信中确认登录：发请求(url=https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/qrcode?code=${wx_code}&state=${n}) 获取openId、signature、newticket、nickname等信息，然是通过this.props.onLoginSuccess(b)返回给上层父组件。
        - 已扫码
        - 取消
        - 超时，则重试3次
        - 出错则重试
        - KEEP_ALIVE，则继续轮询
        - 取消
  2. 记录日志app_main_login
        ```
        // post请求，url地址如下
        https://servicewechat.com/wxa-dev-logic/clientreport
        ```
        
## 总结
1. https://servicewechat.com/connect/qrconnect 处理一些逻辑，并重定向redirect_uri
2. https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/qrcode&scope=snsapi_login&state=login#wechat_redirect 请求中获取到qrcode和长轮询longPollURL
3. 长轮询的响应是javascript，执行该js获取结果。如果用户扫码成功，则可以获取code，异常则进行异常处理。
4. 获取code后，请求https://mp.weixin.qq.com/debug/cgi-bin/webdebugger/qrcode?code=${wx_code}&state=${n} 获取openId等信息后，则表示登录成功

# 登录成功后的下一步
1. dispatch 窗口类型：
```
{
        type: d.WINDOW_SET_MAIN_WINDOW,
        mainWindow: a   // LOGIN、ENTRANCE、SELECT_PROJECT、CREATE_PROJECT、CREATE_MINICODE、IMPORT_MINICODE、DEV、WEB_DEBUGGER
}
```
2. dispatch登录
```
{
        type: d.USER_LOGIN_SUCCESS,
        userInfo: a
}
```
3. 窗口顺序：LOGIN -》 ENTRANCE
```
this.props.mainWindow === d.MAIN_WINDOW_TYPE.LOGIN && this.props.hasLogin && this.props.setMainWindow(d.MAIN_WINDOW_TYPE.ENTRANCE)
```
